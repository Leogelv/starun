---
description: 
globs: 
alwaysApply: true
---
Пушим всегда в ветку master и деплоим на vercel через CLI - мы уже подключены к проекту. XTH
практики у нас все в contents



# Архитектура проекта

## Обзор

Проект представляет собой Telegram Mini App на React, разработанное с использованием следующих технологий:
- React + TypeScript
- @telegram-apps/sdk-react для взаимодействия с Telegram API
- @telegram-apps/telegram-ui для компонентов UI
- TON Connect для интеграции с блокчейном TON
- Vite для сборки
- Supabase для хранения данных пользователей и других сущностей

## Структура файлов

```
reactjs-template
  ├── src
  │   ├── components          # Общие компоненты
  │   │   ├── AppWrapper      # Обертка для всего приложения, управляет fullscreen и safe area
  │   │   ├── DisplayData     # Отображение данных
  │   │   ├── ServerStatus    # Индикатор статуса соединения с сервером
  │   │   ├── SafeAreaFade    # Обработка safe area для TG Mini Apps
  │   │   ├── TabBar          # Нижний таб-бар для навигации
  │   │   ├── Link            # Компонент для навигации между страницами
  │   │   └── ...             # Другие компоненты
  │   ├── css                 # Стили
  │   ├── helpers             # Вспомогательные функции
  │   ├── lib                 # Библиотеки и клиенты внешних сервисов
  │   │   └── supabase        # Клиент и хуки для работы с Supabase
  │   │       ├── client.ts   # Инициализация клиента Supabase
  │   │       ├── types.ts    # Типы данных для Supabase
  │   │       └── hooks       # React хуки для работы с Supabase
  │   ├── navigation          # Маршрутизация
  │   ├── pages               # Страницы приложения
  │   │   ├── IndexPage       # Главная страница
  │   │   ├── ProfilePage     # Страница профиля
  │   │   ├── DiagnosticsPage # Диагностика соединений
  │   │   ├── QuizFlow        # Страницы для квиза выбора практики
  │   │   │   ├── QuizStart   # Стартовая страница квиза
  │   │   │   ├── QuizTypeSelection # Выбор типа практики
  │   │   │   ├── QuizTimeSelection # Выбор времени практики
  │   │   │   ├── QuizGoalSelection # Выбор цели практики
  │   │   │   └── ...         # Другие страницы квиза
  │   │   ├── PracticePage    # Страница с практикой и плеером
  │   │   ├── AdminPage       # Админ-панель (будет добавлена)
  │   │   └── ...             # Другие страницы
  │   ├── contexts            # React контексты
  │   │   ├── UserContext     # Контекст данных пользователя
  │   │   ├── QuizContext     # Контекст состояния квиза
  │   │   ├── PlayerContext   # Контекст для плееров
  │   │   └── ...             # Другие контексты
  │   ├── index.tsx           # Точка входа
  │   ├── init.ts             # Инициализация приложения
  │   └── mockEnv.ts          # Мок Telegram окружения для локальной разработки
  ├── public                  # Статические файлы
  ├── dist                    # Скомпилированные файлы (создаются при сборке)
  │   ├── assets              # Скомпилированные JS, CSS и другие ресурсы
  │   ├── index.html          # Основной HTML файл
  │   └── ...                 # Другие файлы сборки
  └── ...                     # Другие конфигурационные файлы
```

## Основные компоненты

### Компонент AppWrapper

AppWrapper служит основной оберткой для всего приложения и выполняет следующие функции:

1. **Управление полноэкранным режимом**
   - Автоматически включает fullscreen при старте приложения
   - Отключает вертикальные свайпы для предотвращения случайного закрытия
   - Управляет отступами при полноэкранном режиме

2. **Обработка safe area**
   - Запрашивает информацию о safe area у Telegram
   - Устанавливает CSS переменные для применения отступов
   - Обновляет значения при изменении viewport

3. **Обработка событий Telegram**
   - Слушает события `safe_area_changed`, `viewport_changed` и другие
   - Применяет соответствующие настройки к интерфейсу

### Страницы

- **IndexPage** - Главная страница с навигацией по доступным функциям
- **ProfilePage** - Страница профиля пользователя с фото и функцией fullscreen
- **InitDataPage** - Страница для отображения данных initData от Telegram
- **LaunchParamsPage** - Страница с параметрами запуска приложения
- **ThemeParamsPage** - Страница с параметрами темы Telegram
- **TONConnectPage** - Страница для подключения TON кошелька
- **DiagnosticsPage** - Страница для диагностики соединения с Supabase и сервером
- **QuizFlow** - Набор страниц для прохождения квиза и выбора практики
- **PracticePage** - Страница для воспроизведения практик с разными режимами плеера

### Контексты для управления состоянием

1. **UserContext**
   - Хранит данные профиля пользователя
   - Управляет авторизацией и сессией
   - Отслеживает изменения в профиле

2. **QuizContext**
   - Хранит текущее состояние квиза
   - Отслеживает выбранные пользователем параметры
   - Сохраняет состояние между сессиями через localStorage

3. **PlayerContext**
   - Управляет состоянием плеера (видео, аудио, таймер)
   - Хранит настройки воспроизведения
   - Синхронизирует состояние между разными типами плееров

### Система квиза

Система квиза для подбора практик состоит из следующих компонентов:

1. **Страницы квиза**
   - `QuizStart` - Стартовая страница с описанием процесса
   - `QuizTypeSelection` - Выбор типа практики
   - `QuizTimeSelection` - Выбор длительности практики
   - `QuizGoalSelection` - Выбор цели практики
   - `QuizApproachSelection` - Выбор подхода (для медитаций)
   - `QuizObjectSelection` - Выбор объекта концентрации (для самостоятельных медитаций)

2. **Логика фильтрации**
   - Пошаговая фильтрация практик на основе выбора пользователя
   - Подбор оптимальной практики из доступных опций
   - Рандомизация выбора при наличии нескольких подходящих вариантов

3. **Хуки для работы с квизом**
   - `useQuizState` - управление состоянием квиза
   - `useQuizNavigation` - навигация между шагами
   - `useQuizResults` - получение и обработка результатов

### Особенности реализации

1. **Получение данных пользователя**
   - Используем `initDataState` из `@telegram-apps/sdk-react` для получения информации о пользователе, включая фото
   
2. **Интеграция с Supabase**
   - Клиент Supabase инициализируется в `src/lib/supabase/client.ts`
   - Хук `useSupabaseUser` проверяет/создает/обновляет пользователя в Supabase на основе данных из Telegram
   - В `IndexPage` отображается статус подключения и данные пользователя из Supabase
   - Реализовано получение списка всех пользователей из таблицы `public.users`
   - Реализована диагностика соединения с Supabase через `DiagnosticsPage`
   
3. **Проверка окружения**
   - Реализована проверка запуска приложения внутри Telegram или в браузере
   - Для браузеров показывается специальное сообщение "Доступно только в приложениях Telegram"
   - Проверку можно отключить через переменную окружения `NEXT_PUBLIC_ALLOW_BROWSER_ACCESS=true`

4. **Функционал fullscreen**
   - Реализовано с использованием методов Telegram Mini Apps API:
     - `web_app_request_fullscreen` - запрос на полноэкранный режим
     - `web_app_exit_fullscreen` - выход из полноэкранного режима

5. **Навигация**
   - Реализована через React Router с использованием HashRouter
   - Маршруты определены в файле `navigation/routes.tsx`

6. **Система плееров**
   - Видео-плеер для телесных и дыхательных практик (с использованием Kinescope)
   - Аудио-плеер для медитаций с сопровождением
   - Таймер с визуализацией для самостоятельных медитаций

## Структура базы данных

### Таблицы
1. **public.users** - Основная таблица пользователей:
   - `id` - UUID, первичный ключ (генерируется автоматически)
   - `telegram_id` - ID пользователя в Telegram
   - `first_name` - Имя пользователя из Telegram
   - `last_name` - Фамилия пользователя из Telegram
   - `username` - Юзернейм в Telegram (может быть null)
   - `photo_url` - URL фото профиля из Telegram (может быть null)
   - `auth_date` - Дата авторизации из Telegram
   - `hash` - Хеш данных инициализации из Telegram
   - `last_login` - Дата последнего входа (timestamptz)
   - `created_at` - Дата создания записи (timestamptz с default now())
   - `updated_at` - Дата обновления записи (timestamptz с default now())

2. **public.content_types** - Типы контента:
   - `id` - UUID, первичный ключ (генерируется автоматически)
   - `name` - Название типа контента (not null)
   - `slug` - Короткий идентификатор типа (not null)
   - `description` - Описание типа контента (not null)
   - `created_at` - Дата создания записи (timestamptz, not null)

3. **public.categories** - Категории контента:
   - `id` - UUID, первичный ключ (генерируется автоматически)
   - `name` - Название категории (not null)
   - `slug` - Короткий идентификатор категории (not null)
   - `description` - Описание категории
   - `icon` - URL иконки категории
   - `color` - Цвет категории (hex или название)
   - `display_order` - Порядок отображения категории
   - `created_at` - Дата создания (timestamptz с default now())
   - `updated_at` - Дата обновления (timestamptz с default now())

4. **public.contents** - Контент (медитации, курсы, материалы):
   - `id` - UUID, первичный ключ
   - `title` - Заголовок контента (not null)
   - `subtitle` - Подзаголовок
   - `description` - Описание контента
   - `duration` - Продолжительность в секундах
   - `thumbnail_url` - URL миниатюры
   - `background_image_url` - URL фонового изображения
   - `content_type_id` - Внешний ключ на таблицу content_types
   - `category_id` - Внешний ключ на таблицу categories
   - `difficulty_level` - Уровень сложности
   - `kinescope_id` - ID видео в Kinescope
   - `audio_file_path` - Путь к аудиофайлу
   - `is_premium` - Флаг премиум-контента
   - `is_featured` - Флаг рекомендуемого контента
   - `display_order` - Порядок отображения
   - `metadata` - Дополнительные метаданные (JSONB)
   - `created_at` - Дата создания (timestamptz)
   - `updated_at` - Дата обновления (timestamptz)

5. **public.quiz_logic** - Логика квиза и правила подбора практик:
   - `id` - UUID, первичный ключ
   - `practice_type` - Тип практики (телесная, дыхательная, медитация, short)
   - `duration_min` - Минимальная длительность в секундах
   - `duration_max` - Максимальная длительность в секундах
   - `goal` - Цель практики
   - `approach` - Подход (для медитаций: самостоятельная, с сопровождением)
   - `content_id` - Ссылка на контент (FK к contents.id)
   - `priority` - Приоритет для выбора при нескольких совпадениях
   - `created_at` - Дата создания (timestamptz)
   - `updated_at` - Дата обновления (timestamptz)

6. **public.user_quiz_history** - История выборов пользователя в квизе:
   - `id` - UUID, первичный ключ
   - `user_id` - ID пользователя (FK к users.id)
   - `practice_type` - Выбранный тип практики
   - `duration` - Выбранная длительность
   - `goal` - Выбранная цель
   - `approach` - Выбранный подход
   - `content_id` - ID рекомендованного контента
   - `completed` - Флаг завершения практики
   - `created_at` - Дата создания (timestamptz)

7. **public.user_stats** - Статистика пользователя:
   - `id` - UUID, первичный ключ
   - `user_id` - ID пользователя (FK к users.id)
   - `total_practices` - Общее количество практик
   - `total_duration` - Общая продолжительность практик в секундах
   - `last_practice_at` - Дата последней практики
   - `streak_days` - Текущая серия дней с практиками
   - `max_streak_days` - Максимальная серия дней с практиками
   - `practice_stats` - JSON с детальной статистикой по типам практик
   - `updated_at` - Дата обновления (timestamptz)

### Связи между таблицами
1. **contents -> categories**: `contents.category_id` -> `categories.id` (fk_category)
2. **contents -> content_types**: `contents.content_type_id` -> `content_types.id` (fk_content_type)
3. **quiz_logic -> contents**: `quiz_logic.content_id` -> `contents.id` (fk_content)
4. **user_quiz_history -> users**: `user_quiz_history.user_id` -> `users.id` (fk_user)
5. **user_quiz_history -> contents**: `user_quiz_history.content_id` -> `contents.id` (fk_content)
6. **user_stats -> users**: `user_stats.user_id` -> `users.id` (fk_user)

### Раздел администрирования

В проекте будет реализована админ-панель для управления контентом и настройками квиза:

1. **Управление практиками**
   - CRUD операции для практик (создание, чтение, обновление, удаление)
   - Загрузка медиафайлов (видео через Kinescope, аудио через Supabase)
   - Категоризация практик
   - Установка параметров (длительность, сложность, тип и т.д.)

2. **Управление квизом**
   - Настройка логики выбора практик
   - Редактирование вариантов ответов на каждом шаге
   - Управление правилами фильтрации
   - Настройка приоритетов для рекомендаций

3. **Управление пользователями**
   - Просмотр списка пользователей
   - Статистика использования приложения
   - Аналитика по типам практик и целям

4. **Настройки приложения**
   - Управление текстами и описаниями
   - Настройка параметров интерфейса
   - Управление уведомлениями

### Известные особенности и проблемы
- Первоначально таблица `public.users` имела ограничение внешнего ключа `users_id_fkey`, связывающее поле `id` с `auth.users.id`. Это вызывало ошибки при создании пользователей, так как auth.users не содержала соответствующих записей. Ограничение было удалено.
- Для корректной работы приложения в браузере (в режиме разработки или тестирования) необходимо установить переменную окружения `NEXT_PUBLIC_ALLOW_BROWSER_ACCESS=true`.
- Таблица `contents` содержит ссылки на типы контента и категории, что позволяет организовать контент в иерархическую структуру.
- RLS (Row Level Security) включен для таблиц categories и content_types, но отключен для таблиц users и contents.
- Папка `dist` содержит скомпилированные файлы приложения после сборки и необходима для деплоя. Не следует изменять файлы в этой папке вручную.

## Специальные методы Telegram

В проекте используются следующие методы Telegram Mini Apps API:
- `postEvent('web_app_request_fullscreen')` - запрос на полноэкранный режим
- `postEvent('web_app_exit_fullscreen')` - выход из полноэкранного режима
- `postEvent('web_app_setup_swipe_behavior')` - настройка поведения свайпов
- `postEvent('web_app_request_safe_area')` - запрос информации о safe area
- `postEvent('web_app_request_viewport')` - запрос информации о viewport
- `initDataState` и `initDataRaw` - для получения данных пользователя от Telegram

## Переменные окружения

Проект использует следующие переменные окружения:
- `NEXT_PUBLIC_SUPABASE_URL` - URL Supabase API
- `NEXT_PUBLIC_SUPABASE_ANON_KEY` - Публичный ключ Supabase для анонимного доступа
- `NEXT_PUBLIC_ALLOW_BROWSER_ACCESS` - Флаг, позволяющий отключить проверку окружения Telegram (true/false)
- `NEXT_PUBLIC_IGNORE_BUILD_ERROR` - Флаг для игнорирования ошибок сборки
- `SUPABASE_PROJECT_ID` - ID проекта Supabase
- `SUPABASE_PROJECT_URL` - URL проекта Supabase
- `SUPABASE_SERVICE_KEY` - Сервисный ключ Supabase (с правами администратора)
- `VITE_SUPABASE_URL` - URL Supabase для Vite
- `VITE_SUPABASE_ANON_KEY` - Анонимный ключ Supabase для Vite

### Особенности деплоя
- Все перечисленные выше переменные окружения должны быть установлены в Vercel.
- При локальной разработке переменные хранятся в файле `.env.local`.
- Для деплоя на Vercel используется CLI команда `vercel deploy --prod`.

## Процесс разработки квиза и рекомендаций

### Логика квиза

Для реализации квиза будет использоваться следующий процесс:

1. **Создание таблицы quiz_logic**
   - Таблица будет содержать правила подбора практик на основе выбранных параметров
   - Каждая запись связывает комбинацию параметров с конкретным контентом
   - Поле priority позволяет управлять порядком рекомендаций

2. **Логика фильтрации**
   - На каждом шаге квиза применяется фильтрация набора подходящих практик
   - В случае множественных совпадений выбирается случайная практика из подходящих
   - Если точного совпадения нет, выбирается наиболее близкая практика по параметрам

3. **История и персонализация**
   - Сохранение истории выборов пользователя в таблице user_quiz_history
   - Учет предыдущих рекомендаций для разнообразия предложений
   - Постепенное формирование профиля предпочтений пользователя

### Интеграция плееров

Для воспроизведения практик будут реализованы три типа плееров:

1. **Видео-плеер**
   - Интеграция с Kinescope для видеоконтента
   - Адаптивное отображение с учетом типа устройства
   - Полноэкранный режим через Telegram API

2. **Аудио-плеер**
   - Специализированный интерфейс для медитаций
   - Визуальное сопровождение в виде фоновых изображений или анимаций
   - Управление скоростью воспроизведения и громкостью

3. **Таймер для медитаций**
   - Визуализация времени в виде круговой анимации
   - Фоновые звуки (опционально)
   - Настраиваемые уведомления о завершении

## Система плееров

В приложении реализованы три типа плееров для разных видов практик:

1. **VideoPlayer**
   - Использует Kinescope для воспроизведения видео-практик
   - Асинхронно загружает Kinescope API
   - Обрабатывает управление воспроизведением, громкостью и скоростью
   - Поддерживает полноэкранный режим
   - Выполняет синхронизацию состояния с PlayerContext

2. **AudioPlayer**
   - Интерактивный плеер для аудио-медитаций
   - Прогресс-бар с управлением временем воспроизведения
   - Визуализация времени и прогресса воспроизведения
   - Настройка громкости и скорости
   - Фоновое изображение для визуального сопровождения

3. **TimerPlayer**
   - Специализированный плеер для самостоятельных медитаций
   - Круговая визуализация оставшегося времени через Canvas API
   - Настраиваемая продолжительность и объект концентрации
   - Поддержка паузы и сброса таймера
   - Визуальные подсказки и инструкции для медитаций

### Страница практики (PracticePage)

PracticePage - это универсальный компонент, который:

1. **Динамически выбирает плеер** в зависимости от типа контента (видео, аудио, таймер)
2. **Загружает данные контента** из Supabase по ID
3. **Обрабатывает различные варианты URL**:
   - `/practice/:contentId` - для обычных практик
   - `/practice/meditation/:meditationType/:meditationObject` - для самостоятельных медитаций
   - `/practice/:contentId/:meditationType` - для комбинированных случаев
4. **Управляет состоянием плеера** через контекст PlayerContext
5. **Предоставляет интерфейс** для возврата к выбору практики и возможность поделиться

### Логика квиза в базе данных

Для реализации квиза в базе данных используется следующая структура:

1. **Таблица quiz_logic**
   - `practice_type` - Тип практики (short, physical, breathing, meditation)
   - `duration_min` и `duration_max` - Диапазон продолжительности в секундах
   - `goal` - Цель практики (например, "energize", "relax", "stretch")
   - `approach` - Подход для медитации ("self" или "guided")
   - `content_id` - Связь с конкретным контентом
   - `priority` - Приоритет для выбора при множественных совпадениях

2. **Процесс фильтрации в квизе**
   - На каждом шаге применяются новые фильтры (тип, длительность, цель и т.д.)
   - SQL-запросы учитывают предыдущие выборы пользователя
   - При множественных совпадениях приоритет отдается записям с выставленным приоритетом
   - Если точного совпадения нет, выбирается наиболее близкий вариант

3. **Сценарии подбора практик**
   - Короткие практики (до 7 минут) фильтруются только по цели
   - Телесные практики фильтруются по продолжительности и фокусу
   - Дыхательные практики фильтруются по цели
   - Медитации делятся на самостоятельные и с сопровождением

4. **Типы целей практик**
   - Для коротких: energize, relax, stretch, focus
   - Для телесных: legs, whole_body, shoulders, core, digestive, back_pain, hormonal
   - Для дыхательных: stress_relief, sleep, energy, focus, breathing_depth, complex
   - Для медитаций: body, thinking, relationships

5. **Хранение истории квиза**
   - В таблице `user_quiz_history` сохраняются все выборы пользователя
   - Это позволяет анализировать предпочтения и улучшать рекомендации
   - Также отслеживается факт завершения практики

## Realtime обновления и оптимизации

### Принцип работы Realtime соединения

В проекте активно используется Supabase Realtime для обеспечения актуальности данных на клиенте. Realtime компонент работает через WebSocket соединение и уведомляет клиентов об изменениях в таблицах базы данных в режиме реального времени.

1. **Типы подписок в проекте:**
   - Подписка на изменения в профиле текущего пользователя (`subscribeToUserChanges` в `client.ts`)
   - Общая подписка на таблицу users для отображения списка всех пользователей
   - Мониторинг статуса Realtime соединения через системные события и presence

2. **Потенциальные проблемы:**
   - Каскадные обновления: изменение записи пользователя может вызвать множественные события
   - Избыточные запросы из-за частых событий Realtime
   - Цикличные обновления (A обновляет B, B вызывает обновление A и т.д.)

### Оптимизации и паттерны

Для предотвращения проблем с Realtime обновлениями применены следующие оптимизации:

1. **Debounce и throttling:**
   - В хуке `useSupabaseUser`: debounce обновлений состояния с задержкой 300 мс
   - В `IndexPage`: throttling обновлений списка пользователей с минимальным интервалом 2 секунды

2. **Отслеживание дубликатов:**
   - Хранение ID и времени последнего обновления
   - Фильтрация повторных событий с одинаковыми данными
   - Игнорирование обновлений, слишком близких по времени

3. **Управление жизненным циклом подписок:**
   - Корректное создание/удаление подписок при монтировании/размонтировании компонентов
   - Явная очистка всех таймеров при размонтировании
   - Использование useRef для хранения ссылок на подписки

4. **Оптимизация потоков данных:**
   - Контролируемые обновления состояния с проверкой необходимости обновления
   - Предотвращение каскадных обновлений через проверку и обновление флагов состояния
   - Логирование всех событий для диагностики и отладки

### Пример паттерна обработки Realtime событий:

```typescript
// 1. Создание и хранение ссылок
const channelRef = useRef<RealtimeChannel | null>(null);
const lastUpdateTimeRef = useRef<number>(0);

// 2. Настройка подписки
channelRef.current = supabase.channel('channel-name')
  .on('postgres_changes', {
    event: '*',
    schema: 'public',
    table: 'tablename',
  }, (payload) => {
    // 3. Проверка и фильтрация событий
    const now = Date.now();
    if (now - lastUpdateTimeRef.current < 200) {
      return; // Игнорируем слишком частые обновления
    }
    
    // 4. Обновление через debounce
    if (debounceTimerRef.current !== null) {
      clearTimeout(debounceTimerRef.current);
    }
    
    debounceTimerRef.current = setTimeout(() => {
      // 5. Здесь выполняем обновление состояния
      setState(newState);
      debounceTimerRef.current = null;
    }, 300);
    
    lastUpdateTimeRef.current = now;
  })
  .subscribe();

// 6. Очистка при размонтировании
useEffect(() => {
  return () => {
    if (channelRef.current) {
      channelRef.current.unsubscribe();
    }
    if (debounceTimerRef.current !== null) {
      clearTimeout(debounceTimerRef.current);
    }
  };
}, []);
```

## Последняя верификация

Структура проекта верифицирована: 05.11.2024 
